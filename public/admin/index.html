<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TradeTrends Admin</title>
  <meta name="robots" content="noindex,nofollow" />
  <meta name="theme-color" content="#0b1118" />
  <link rel="stylesheet" href="/admin/admin.css" />
</head>
<body>
  <script>
    // Diagnostic: Check if config.yml loads correctly
    fetch('/admin/config.yml')
      .then(res => {
        console.log('üìã Config check:', res.status, res.headers.get('content-type'));
        return res.text();
      })
      .then(text => {
        if (text.startsWith('<!DOCTYPE') || text.includes('<html')) {
          console.error('‚ùå CRITICAL: /admin/config.yml returned HTML instead of YAML!');
          console.error('This means Netlify redirects are rewriting admin assets.');
          console.error('Fix: Add /admin/* exception in netlify.toml BEFORE catch-all redirect.');
        } else if (text.startsWith('backend:') || text.includes('collections:')) {
          console.log('‚úÖ Config.yml loaded correctly as YAML');
        } else {
          console.warn('‚ö†Ô∏è Unexpected config.yml content:', text.substring(0, 100));
        }
      })
      .catch(err => {
        console.error('‚ùå Failed to load config.yml:', err);
      });
  </script>

  <!-- Access Denied Message (hidden by default) -->
  <div id="accessDenied">
    <h2>Access Denied</h2>
    <p>This admin dashboard is restricted to users with the <strong>admin</strong> role.</p>
    <p>If you believe you should have access, please contact the site administrator.</p>
  </div>

  <!-- Decap CMS Mount Point -->
  <div id="nc-root"></div>

  <!-- Netlify Identity (login) -->
  <script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>

  <!-- Decap CMS (Netlify CMS successor) -->
  <script src="https://unpkg.com/decap-cms@^3.0.0/dist/decap-cms.js"></script>

  <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CMS-SAFE URL-FIRST AUTO-FILL SYSTEM FOR DECAP CMS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // Track fields that have been manually edited (never overwrite these)
    const touchedFieldsMap = new Map();
    
    // ‚îÄ‚îÄ‚îÄ UTILITY FUNCTIONS ‚îÄ‚îÄ‚îÄ
    
    function generateId(text) {
      if (!text) return '';
      return text
        .toLowerCase()
        .replace(/[^a-z0-9\s-]/g, '')
        .trim()
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .substring(0, 60);
    }
    
    function generateIdFromAsin(asin) {
      return `amz-${asin.toLowerCase()}`;
    }
    
    function generateIdFromUrl(url) {
      try {
        const urlObj = new URL(url);
        const hostname = urlObj.hostname.replace('www.', '');
        const hash = Math.random().toString(36).substring(2, 8);
        return `${hostname.split('.')[0]}-${hash}`;
      } catch {
        return 'deal-' + Math.random().toString(36).substring(2, 10);
      }
    }
    
    // ‚îÄ‚îÄ‚îÄ CATEGORY INFERENCE (CONSERVATIVE) ‚îÄ‚îÄ‚îÄ
    
    function inferCategory(keywords, network) {
      if (network === 'amazon') {
        const keywordStr = keywords.join(' ').toLowerCase();
        
        if (keywordStr.match(/electronic|power|charging|battery|usb|tech/)) return 'Electronics';
        if (keywordStr.match(/kitchen|cooking|cook|food|recipe/)) return 'Kitchen';
        if (keywordStr.match(/home|decor|furniture|living/)) return 'Home';
        if (keywordStr.match(/outdoor|camping|hiking|tent|backpack/)) return 'Outdoors';
        if (keywordStr.match(/beauty|skin|makeup|cosmetic/)) return 'Beauty';
        if (keywordStr.match(/toy|game|play/)) return 'Toys';
        if (keywordStr.match(/book|read/)) return 'Books';
        if (keywordStr.match(/cloth|fashion|apparel|wear/)) return 'Fashion';
        if (keywordStr.match(/pet|dog|cat/)) return 'Pets';
        if (keywordStr.match(/health|fitness|workout|exercise/)) return 'Health';
        
        return '';
      } else if (network === 'travel') {
        return 'Hotels';
      }
      
      return '';
    }
    
    // ‚îÄ‚îÄ‚îÄ RESOLVE URL VIA NETLIFY FUNCTION ‚îÄ‚îÄ‚îÄ
    
    async function resolveUrl(url) {
      try {
        const encodedUrl = encodeURIComponent(url);
        const response = await fetch(`/.netlify/functions/resolve?url=${encodedUrl}`);
        
        if (!response.ok) {
          throw new Error('Resolution failed');
        }
        
        const data = await response.json();
        
        if (!data.ok) {
          throw new Error(data.error || 'Unknown error');
        }
        
        return data;
      } catch (error) {
        console.warn('URL resolution failed, using direct parsing:', error);
        return fallbackResolve(url);
      }
    }
    
    function fallbackResolve(url) {
      try {
        const urlObj = new URL(url);
        const hostname = urlObj.hostname.replace('www.', '').toLowerCase();
        
        let network = 'other';
        if (hostname.includes('amazon.')) network = 'amazon';
        else if (hostname.includes('booking.') || hostname.includes('expedia.') || 
                 hostname.includes('hotels.') || hostname.includes('airbnb.')) network = 'travel';
        
        return {
          ok: true,
          finalUrl: url,
          hostname,
          network,
          asin: null,
          keywords: []
        };
      } catch {
        return { ok: false, error: 'Invalid URL' };
      }
    }
    
    // ‚îÄ‚îÄ‚îÄ CMS-SAFE AUTO-FILL USING EVENT LISTENERS ‚îÄ‚îÄ‚îÄ
    
    async function processUrlAndSuggestValues(entry) {
      const affiliateUrl = entry.getIn(['data', 'affiliate_url']);
      
      if (!affiliateUrl) return entry;
      
      // Check if we've already processed this entry
      const entryId = entry.getIn(['slug']) || Math.random().toString(36).substring(2, 10);
      if (touchedFieldsMap.has(entryId)) {
        console.log('Entry already processed, skipping autofill');
        return entry;
      }
      
      console.log('üéØ Processing URL for autofill:', affiliateUrl);
      
      const resolved = await resolveUrl(affiliateUrl);
      
      if (!resolved.ok) {
        console.warn('Could not resolve URL:', resolved.error);
        return entry;
      }
      
      const { finalUrl, hostname, network, asin, keywords } = resolved;
      console.log('‚úì Resolved:', { finalUrl, hostname, network, asin, keywords });
      
      // Build suggestions object (never overwrite existing values)
      let modified = entry;
      
      // Auto-fill ID if empty
      if (!modified.getIn(['data', 'id'])) {
        let newId = '';
        if (asin && network === 'amazon') {
          newId = generateIdFromAsin(asin);
        } else {
          newId = generateIdFromUrl(finalUrl);
        }
        if (newId) {
          modified = modified.setIn(['data', 'id'], newId);
          console.log('  ‚úì Auto-filled ID:', newId);
        }
      }
      
      // Auto-fill network if empty
      if (!modified.getIn(['data', 'network'])) {
        modified = modified.setIn(['data', 'network'], network);
        console.log('  ‚úì Auto-filled Network:', network);
      }
      
      // Suggest category if empty (medium confidence)
      if (!modified.getIn(['data', 'category'])) {
        const category = inferCategory(keywords, network);
        if (category) {
          modified = modified.setIn(['data', 'category'], category);
          console.log('  ‚úì Suggested Category:', category);
        }
      }
      
      // Auto-fill brand for travel if empty
      if (network === 'travel' && !modified.getIn(['data', 'brand'])) {
        const brand = hostname.split('.')[0];
        const brandName = brand.charAt(0).toUpperCase() + brand.slice(1);
        modified = modified.setIn(['data', 'brand'], brandName);
        console.log('  ‚úì Auto-filled Brand:', brandName);
      }
      
      // Mark this entry as processed
      touchedFieldsMap.set(entryId, true);
      
      return modified;
    }
    
    // ‚îÄ‚îÄ‚îÄ INITIALIZE DECAP CMS WITH EVENT LISTENERS ‚îÄ‚îÄ‚îÄ
    
    function initDecapCMS() {
      // Register event listener for entry changes
      if (window.CMS) {
        console.log('üöÄ Initializing CMS-safe autofill system...');
        
        // Listen for preSave events to process affiliate URLs
        CMS.registerEventListener({
          name: 'preSave',
          handler: async ({ entry }) => {
            return await processUrlAndSuggestValues(entry);
          }
        });
        
        console.log('‚úì CMS autofill system ready (no DOM manipulation)');
      }
    }
    
    // Verify #nc-root exists and is visible
    setTimeout(() => {
      const ncRoot = document.getElementById('nc-root');
      if (ncRoot) {
        const rect = ncRoot.getBoundingClientRect();
        console.log('‚úì #nc-root found:', {
          exists: true,
          visible: rect.height > 0,
          dimensions: `${rect.width}x${rect.height}`
        });
      } else {
        console.error('‚ùå #nc-root not found in DOM!');
      }
    }, 500);
    
    // Initialize CMS
    CMS.init();
    
    // Wait for CMS to be fully ready, then register event listeners
    setTimeout(() => {
      initDecapCMS();
    }, 1000);
    
    // Client-side role enforcement for admin access
    if (window.netlifyIdentity) {
      window.netlifyIdentity.on("init", user => {
        if (!user) {
          // Not logged in - open login modal
          window.netlifyIdentity.open("login");
        } else {
          // User is logged in - normalize metadata and check role
          normalizeUserMetadata(user);
          checkAdminAccess(user);
        }
      });

      window.netlifyIdentity.on("login", user => {
        // After login, normalize metadata to prevent widget crashes
        normalizeUserMetadata(user);
        
        // Then check admin access
        checkAdminAccess(user);
        
        // Close the widget modal
        window.netlifyIdentity.close();
      });

      window.netlifyIdentity.init();
    }

    // Normalize user metadata to prevent widget crashes
    function normalizeUserMetadata(user) {
      if (!user) return;
      
      // Ensure user_metadata exists
      if (!user.user_metadata) {
        user.user_metadata = {};
      }
      
      // Fix missing full_name (common with Google login)
      if (!user.user_metadata.full_name) {
        const fallbackName = user.email ? user.email.split('@')[0] : 'User';
        user.user_metadata.full_name = fallbackName;
        
        console.log('Normalized missing full_name:', fallbackName);
        
        // Try to persist the update (may fail silently if permissions don't allow)
        try {
          if (user.update && typeof user.update === 'function') {
            user.update({ user_metadata: user.user_metadata });
          }
        } catch (err) {
          console.warn('Could not persist user_metadata update:', err);
        }
      }
    }

    function checkAdminAccess(user) {
      if (!user) {
        console.error('checkAdminAccess called with null user');
        return;
      }
      
      const accessDenied = document.getElementById('accessDenied');
      const ncRoot = document.getElementById('nc-root');
      
      // Get user roles from app_metadata (NOT from widget UI state)
      const roles = user.app_metadata?.roles || [];
      const isAdmin = roles.includes('admin');
      
      // Get safe display name
      const displayName = user.user_metadata?.full_name || user.email?.split('@')[0] || 'User';
      const roleLabel = isAdmin ? 'Admin' : 'User';

      if (!isAdmin) {
        // User is logged in but not an admin
        if (accessDenied) accessDenied.style.display = 'block';
        if (ncRoot) ncRoot.style.display = 'none';
        console.log('Access denied: User does not have admin role');
        console.log(`User: ${displayName} (${user.email}) - Roles:`, roles);
      } else {
        // User has admin role - show CMS
        if (accessDenied) accessDenied.style.display = 'none';
        if (ncRoot) ncRoot.style.display = 'block';
        console.log(`‚úì Admin access granted: ${displayName} (${user.email})`);
        console.log('User roles:', roles);
      }
      
      // Update any UI elements that show user role
      updateUserRoleDisplay(user, isAdmin, displayName, roleLabel);
    }
    
    function updateUserRoleDisplay(user, isAdmin, displayName, roleLabel) {
      // This function can be extended to update UI elements
      // For now, just log the status
      console.log(`User display: ${displayName} - Role: ${roleLabel}`);
    }
  </script>
</body>
</html>
